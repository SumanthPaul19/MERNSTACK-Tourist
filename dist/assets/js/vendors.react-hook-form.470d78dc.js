(self.webpackChunkproject=self.webpackChunkproject||[]).push([[767],{2283:function(e,r,t){"use strict";t.d(r,{cI:function(){return ve}});var s=t(7294),n=e=>"checkbox"===e.type,a=e=>e instanceof Date,u=e=>null==e;const c=e=>"object"===typeof e;var i=e=>!u(e)&&!Array.isArray(e)&&c(e)&&!a(e),l=e=>e.substring(0,e.search(/.\d/))||e,o=(e,r)=>[...e].some((e=>l(r)===e)),f=e=>e.filter(Boolean),d=e=>void 0===e,b=(e,r,t)=>{if(i(e)&&r){const s=f(r.split(/[,[\].]+?/)).reduce(((e,r)=>u(e)?e:e[r]),e);return d(s)||s===e?d(e[r])?t:e[r]:s}};const y="blur",g="onBlur",h="onChange",m="onSubmit",v="onTouched",p="all",w="max",O="min",k="maxLength",j="minLength",V="pattern",_="required",A="validate";var x=(e,r)=>{const t=Object.assign({},e);return delete t[r],t};const C=s.createContext(null);C.displayName="RHFContext";var D=(e,r,t,s,n=!0)=>e?new Proxy(r,{get:(e,r)=>{if(r in e)return t.current[r]!==p&&(t.current[r]=!n||p),s&&(s.current[r]=!0),e[r]}}):r,S=e=>i(e)&&!Object.keys(e).length,F=(e,r,t)=>{const s=x(e,"name");return S(s)||Object.keys(s).length>=Object.keys(r).length||Object.keys(s).find((e=>r[e]===(!t||p)))},R=e=>Array.isArray(e)?e:[e],E="undefined"!==typeof window&&"undefined"!==typeof window.HTMLElement&&"undefined"!==typeof document;const N=E?"Proxy"in window:"undefined"!==typeof Proxy;var B=(e,r,t,s,n)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[s]:n||!0})}):{},M=e=>/^\w*$/.test(e),T=e=>f(e.replace(/["|']|\]/g,"").split(/\.|\[/));function L(e,r,t){let s=-1;const n=M(r)?[r]:T(r),a=n.length,u=a-1;for(;++s<a;){const r=n[s];let a=t;if(s!==u){const t=e[r];a=i(t)||Array.isArray(t)?t:isNaN(+n[s+1])?{}:[]}e[r]=a,e=e[r]}return e}const I=(e,r,t)=>{for(const s of t||Object.keys(e)){const t=b(e,s);if(t){const e=t._f,s=x(t,"_f");if(e&&r(e.name)){if(e.ref.focus&&d(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else i(s)&&I(s,r)}}},U=(e,r={})=>{for(const t in e.current){const s=e.current[t];if(s&&!u(r)){const e=s._f,n=x(s,"_f");L(r,t,e&&e.ref?e.ref.disabled||e.refs&&e.refs.every((e=>e.disabled))?void 0:e.value:Array.isArray(s)?[]:{}),n&&U({current:n},r[t])}}return r};var P=e=>u(e)||!c(e);function q(e,r,t){if(P(e)||P(r)||a(e)||a(r))return e===r;if(!s.isValidElement(e)){const s=Object.keys(e),n=Object.keys(r);if(s.length!==n.length)return!1;for(const a of s){const s=e[a];if(!t||"ref"!==a){const e=r[a];if((i(s)||Array.isArray(s))&&(i(e)||Array.isArray(e))?!q(s,e,t):s!==e)return!1}}}return!0}function H(e,r){if(P(e)||P(r))return r;for(const s in r){const n=e[s],a=r[s];try{e[s]=i(n)&&i(a)||Array.isArray(n)&&Array.isArray(a)?H(n,a):a}catch(t){}}return e}function $(e,r,t,s,n){let a=-1;for(;++a<e.length;){for(const s in e[a])Array.isArray(e[a][s])?(!t[a]&&(t[a]={}),t[a][s]=[],$(e[a][s],b(r[a]||{},s,[]),t[a][s],t[a],s)):q(b(r[a]||{},s),e[a][s])?L(t[a]||{},s):t[a]=Object.assign(Object.assign({},t[a]),{[s]:!0});s&&!t.length&&delete s[n]}return t}var z=(e,r,t)=>H($(e,r,t.slice(0,e.length)),$(r,e,t.slice(0,e.length)));var G=e=>"boolean"===typeof e;function J(e,r){const t=M(r)?[r]:T(r),s=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let s=0;for(;s<t;)e=d(e)?s++:e[r[s++]];return e}(e,t),n=t[t.length-1];let a;s&&delete s[n];for(let u=0;u<t.slice(0,-1).length;u++){let r,s=-1;const n=t.slice(0,-(u+1)),c=n.length-1;for(u>0&&(a=e);++s<n.length;){const t=n[s];r=r?r[t]:e[t],c===s&&(i(r)&&S(r)||Array.isArray(r)&&!r.filter((e=>i(e)&&!S(e)||G(e))).length)&&(a?delete a[t]:delete e[t]),a=r}}return e}var K=e=>"file"===e.type,Q=e=>"select-multiple"===e.type,W=e=>"radio"===e.type;const X={value:!1,isValid:!1},Y={value:!0,isValid:!0};var Z=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:r,isValid:!!r.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!d(e[0].attributes.value)?d(e[0].value)||""===e[0].value?Y:{value:e[0].value,isValid:!0}:Y:X}return X},ee=(e,{valueAsNumber:r,valueAsDate:t,setValueAs:s})=>d(e)?e:r?""===e?NaN:+e:t?new Date(e):s?s(e):e;const re={isValid:!1,value:null};var te=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.checked&&!r.disabled?{isValid:!0,value:r.value}:e),re):re;function se(e){if(e&&e._f){const t=e._f.ref;if(t.disabled)return;return K(t)?t.files:W(t)?te(e._f.refs).value:Q(t)?(r=t.options,[...r].filter((({selected:e})=>e)).map((({value:e})=>e))):n(t)?Z(e._f.refs).value:ee(d(t.value)?e._f.ref.value:t.value,e._f)}var r}var ne=(e,r,t,s)=>{const n={};for(const a of e){const e=b(r,a);e&&L(n,a,e._f)}return{criteriaMode:t,names:[...e],fields:n,shouldUseNativeValidation:s}},ae=e=>"function"===typeof e,ue=e=>"string"===typeof e,ce=e=>ue(e)||s.isValidElement(e),ie=e=>e instanceof RegExp;function le(e,r,t="validate"){if(ce(e)||Array.isArray(e)&&e.every(ce)||G(e)&&!e)return{type:t,message:ce(e)?e:"",ref:r}}var oe=e=>i(e)&&!ie(e)?e:{value:e,message:""},fe=async({_f:{ref:e,refs:r,required:t,maxLength:s,minLength:a,min:c,max:l,pattern:o,validate:f,name:d,value:b,valueAsNumber:y,mount:g}},h,m)=>{if(!g)return{};const v=r?r[0]:e,p=e=>{m&&v.reportValidity&&(v.setCustomValidity(G(e)?"":e||" "),v.reportValidity())},x={},C=W(e),D=n(e),F=C||D,R=(y||K(e))&&!e.value||""===b||Array.isArray(b)&&!b.length,E=B.bind(null,d,h,x),N=(r,t,s,n=k,a=j)=>{const u=r?t:s;x[d]=Object.assign({type:r?n:a,message:u,ref:e},E(r?n:a,u))};if(t&&(!F&&(R||u(b))||G(b)&&!b||D&&!Z(r).isValid||C&&!te(r).isValid)){const{value:e,message:r}=ce(t)?{value:!!t,message:t}:oe(t);if(e&&(x[d]=Object.assign({type:_,message:r,ref:v},E(_,r)),!h))return p(r),x}if(!R&&(!u(c)||!u(l))){let r,t;const s=oe(l),n=oe(c);if(isNaN(b)){const a=e.valueAsDate||new Date(b);ue(s.value)&&(r=a>new Date(s.value)),ue(n.value)&&(t=a<new Date(n.value))}else{const a=e.valueAsNumber||parseFloat(b);u(s.value)||(r=a>s.value),u(n.value)||(t=a<n.value)}if((r||t)&&(N(!!r,s.message,n.message,w,O),!h))return p(x[d].message),x}if((s||a)&&!R&&ue(b)){const e=oe(s),r=oe(a),t=!u(e.value)&&b.length>e.value,n=!u(r.value)&&b.length<r.value;if((t||n)&&(N(t,e.message,r.message),!h))return p(x[d].message),x}if(o&&!R&&ue(b)){const{value:r,message:t}=oe(o);if(ie(r)&&!b.match(r)&&(x[d]=Object.assign({type:V,message:t,ref:e},E(V,t)),!h))return p(t),x}if(f)if(ae(f)){const e=le(await f(b),v);if(e&&(x[d]=Object.assign(Object.assign({},e),E(A,e.message)),!h))return p(e.message),x}else if(i(f)){let e={};for(const r in f){if(!S(e)&&!h)break;const t=le(await f[r](b),v,r);t&&(e=Object.assign(Object.assign({},t),E(r,t.message)),p(t.message),h&&(x[d]=e))}if(!S(e)&&(x[d]=Object.assign({ref:v},e),!h))return x}return p(!0),x},de=e=>({isOnSubmit:!e||e===m,isOnBlur:e===g,isOnChange:e===h,isOnAll:e===p,isOnTouch:e===v}),be=e=>e instanceof HTMLElement;class ye{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class ge{constructor(e,r){this.observer=e,this.closed=!1,r.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class he{constructor(){this.observers=[]}next(e){for(const r of this.observers)r.next(e)}subscribe(e){const r=new ye,t=new ge(e,r);return this.observers.push(t),r}unsubscribe(){this.observers=[]}}const me="undefined"===typeof window;function ve({mode:e=m,reValidateMode:r=h,resolver:t,context:c,defaultValues:g={},shouldFocusError:v=!0,shouldUseNativeValidation:w,shouldUnregister:O,criteriaMode:k}={}){const[j,V]=s.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}}),_=s.useRef({isDirty:!N,dirtyFields:!N,touchedFields:!N,isValidating:!N,isValid:!N,errors:!N}),A=s.useRef(t),C=s.useRef(j),B=s.useRef({}),M=s.useRef(g),T=s.useRef({}),H=s.useRef(c),$=s.useRef(!1),G=s.useRef(!1),X=s.useRef({watch:new he,control:new he,array:new he,state:new he}),Y=s.useRef({mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1}),Z=de(e),re=k===p;A.current=t,H.current=c;const te=e=>Y.current.watchAll||Y.current.watch.has(e)||Y.current.watch.has((e.match(/\w+/)||[])[0]),ce=s.useCallback((async(e,r,s,n,a,u)=>{const c=b(C.current.errors,r),i=!!_.current.isValid&&(t?a:await ve(B.current,!0));if(s?L(C.current.errors,r,s):J(C.current.errors,r),(u||(s?!q(c,s,!0):c)||!S(n)||C.current.isValid!==i)&&!e){const e=Object.assign(Object.assign({},n),{isValid:!!i,errors:C.current.errors,name:r});C.current=Object.assign(Object.assign({},C.current),e),X.current.state.next(u?{name:r}:e)}X.current.state.next({isValidating:!1})}),[]),ie=s.useCallback(((e,r,t={},s,a)=>{a&&Ce(e);const c=b(B.current,e);if(c){const a=c._f;if(a){const c=E&&be(a.ref)&&u(r)?"":r;if(a.value=ee(r,a),W(a.ref)&&!a._c?(a.refs||[]).forEach((e=>e.checked=e.value===c)):!K(a.ref)||ue(c)||a._c?Q(a.ref)?[...a.ref.options].forEach((e=>e.selected=c.includes(e.value))):n(a.ref)&&a.refs&&!a._c?a.refs.length>1?a.refs.forEach((e=>e.checked=Array.isArray(c)?!!c.find((r=>r===e.value)):c===e.value)):a.refs[0].checked=!!c:a.ref.value=c:a.ref.files=c,s&&a._c){const t=U(B);L(t,e,r),X.current.control.next({values:Object.assign(Object.assign({},M.current),t),name:e})}(t.shouldDirty||t.shouldTouch)&&oe(e,c,t.shouldTouch),t.shouldValidate&&pe(e)}else c._f={ref:{name:e,value:r},value:r}}}),[]),le=s.useCallback(((e,r)=>{const t=U(B);return e&&r&&L(t,e,r),!q(t,M.current)}),[]),oe=s.useCallback(((e,r,t,s=!0)=>{const n={name:e};let a=!1;if(_.current.isDirty){const e=C.current.isDirty;C.current.isDirty=le(),n.isDirty=C.current.isDirty,a=e!==n.isDirty}if(_.current.dirtyFields&&!t){const t=b(C.current.dirtyFields,e);!q(b(M.current,e),r)?L(C.current.dirtyFields,e,!0):J(C.current.dirtyFields,e),n.dirtyFields=C.current.dirtyFields,a=a||t!==b(C.current.dirtyFields,e)}const u=b(C.current.touchedFields,e);return t&&!u&&(L(C.current.touchedFields,e,t),n.touchedFields=C.current.touchedFields,a=a||_.current.touchedFields&&u!==t),a&&s&&X.current.state.next(n),a?n:{}}),[]),ye=s.useCallback((async(e,r)=>{const t=(await fe(b(B.current,e),re,w))[e];return await ce(r,e,t),d(t)}),[re]),ge=s.useCallback((async e=>{const{errors:r}=await A.current(U(B),H.current,ne(Y.current.mount,B.current,k,w));if(e)for(const t of e){const e=b(r,t);e?L(C.current.errors,t,e):J(C.current.errors,t)}else C.current.errors=r;return r}),[k,w]),ve=async(e,r,t={valid:!0})=>{for(const s in e){const n=e[s];if(n){const e=n._f,s=x(n,"_f");if(e){const s=await fe(n,re,w);if(r){if(s[e.name]){t.valid=!1;break}}else s[e.name]?L(C.current.errors,e.name,s[e.name]):J(C.current.errors,e.name)}s&&await ve(s,r,t)}}return t.valid},pe=s.useCallback((async(e,r={})=>{const s=R(e);let n;if(X.current.state.next({isValidating:!0}),t){const r=await ge(d(e)?e:s);n=e?s.every((e=>!b(r,e))):S(r)}else e?n=(await Promise.all(s.filter((e=>b(B.current,e,{})._f)).map((async e=>await ye(e,!0))))).every(Boolean):(await ve(B.current),n=S(C.current.errors));return X.current.state.next(Object.assign(Object.assign({},ue(e)?{name:e}:{}),{errors:C.current.errors,isValidating:!1})),r.shouldFocus&&!n&&I(B.current,(e=>b(C.current.errors,e)),e?s:Y.current.mount),_.current.isValid&&Oe(),n}),[ge,ye]),we=(e,r)=>{const t=b(B.current,e);if(t){const s=d(t._f.value),n=s?d(b(T.current,e))?b(M.current,e):b(T.current,e):t._f.value;d(n)?s&&(t._f.value=se(t)):r&&r.defaultChecked?t._f.value=se(t):ie(e,n)}G.current&&_.current.isValid&&Oe()},Oe=s.useCallback((async(e={})=>{const r=t?S((await A.current(Object.assign(Object.assign({},U(B)),e),H.current,ne(Y.current.mount,B.current,k,w))).errors):await ve(B.current,!0);r!==C.current.isValid&&X.current.state.next({isValid:r})}),[k,w]),ke=s.useCallback(((e,r,t)=>Object.entries(r).forEach((([r,s])=>{const n=`${e}.${r}`,u=b(B.current,n);!Y.current.array.has(e)&&P(s)&&(!u||u._f)||a(s)?ie(n,s,t,!0,!u):ke(n,s,t)}))),[pe]),je=s.useCallback((async({type:e,target:s,target:{value:a,name:u,type:c}})=>{let i,o;const f=b(B.current,u);if(f){let h=c?se(f):void 0;h=d(h)?a:h;const m=e===y,{isOnBlur:v,isOnChange:p}=de(r),O=(g=f._f,!(f._f.mount&&g&&(g.required||g.min||g.max||g.maxLength||g.minLength||g.pattern||g.validate))&&!t&&!b(C.current.errors,u)||(({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:s,isReValidateOnBlur:n,isReValidateOnChange:a,isBlurEvent:u,isSubmitted:c,isOnAll:i})=>!i&&(!c&&t?!(s||u):(c?n:e)?!u:!(c?a:r)||u))(Object.assign({isBlurEvent:m,isTouched:!!b(C.current.touchedFields,u),isSubmitted:C.current.isSubmitted,isReValidateOnBlur:v,isReValidateOnChange:p},Z))),j=!m&&te(u);d(h)||(f._f.value=h);const V=oe(u,f._f.value,m,!1),_=!S(V)||j;if(O)return!m&&X.current.watch.next({name:u,type:e,values:Ve()}),_&&X.current.state.next(j?{name:u}:Object.assign(Object.assign({},V),{name:u}));if(X.current.state.next({isValidating:!0}),t){const{errors:e}=await A.current(U(B),H.current,ne([u],B.current,k,w));if(i=b(e,u),n(s)&&!i){const r=l(u),t=b(e,r,{});t.type&&t.message&&(i=t),(t||b(C.current.errors,r))&&(u=r)}o=S(e)}else i=(await fe(f,re,w))[u];!m&&X.current.watch.next({name:u,type:e,values:Ve()}),ce(!1,u,i,V,o,j)}var g}),[]),Ve=e=>{const r=Object.assign(Object.assign({},M.current),U(B));return d(e)?r:ue(e)?b(r,e):e.map((e=>b(r,e)))},_e=s.useCallback(((e,r,t,s)=>{const n=Array.isArray(e),a=s||G.current?Object.assign(Object.assign({},M.current),s||U(B)):d(r)?M.current:n?r:{[e]:r};if(d(e))return t&&(Y.current.watchAll=!0),a;const u=[];for(const c of R(e))t&&Y.current.watch.add(c),u.push(b(a,c));return n?u:u[0]}),[]),Ae=(e,r={})=>{for(const t of e?R(e):Y.current.mount)Y.current.mount.delete(t),Y.current.array.delete(t),b(B.current,t)&&(!r.keepError&&J(C.current.errors,t),!r.keepValue&&J(B.current,t),!r.keepDirty&&J(C.current.dirtyFields,t),!r.keepTouched&&J(C.current.touchedFields,t),!O&&!r.keepDefaultValue&&J(M.current,t));X.current.watch.next({values:Ve()}),X.current.state.next(Object.assign(Object.assign({},C.current),r.keepDirty?{isDirty:le()}:{})),!r.keepIsValid&&Oe()},xe=(e,r,t)=>{Ce(e,t);let s=b(B.current,e);const a=(e=>W(e)||n(e))(r);r===s._f.ref||a&&f(s._f.refs||[]).find((e=>e===r))||(s={_f:a?Object.assign(Object.assign({},s._f),{refs:[...f(s._f.refs||[]).filter((e=>be(e)&&document.contains(e))),r],ref:{type:r.type,name:e}}):Object.assign(Object.assign({},s._f),{ref:r})},L(B.current,e,s),we(e,r))},Ce=s.useCallback(((e,r={})=>{const t=b(B.current,e);return L(B.current,e,{_f:Object.assign(Object.assign(Object.assign({},t&&t._f?t._f:{ref:{name:e}}),{name:e,mount:!0}),r)}),Y.current.mount.add(e),!t&&we(e),me?{name:e}:{name:e,onChange:je,onBlur:je,ref:t=>{if(t)xe(e,t,r);else{const t=b(B.current,e,{}),s=O||r.shouldUnregister;t._f&&(t._f.mount=!1,d(t._f.value)&&(t._f.value=t._f.ref.value)),s&&(!o(Y.current.array,e)||!$.current)&&Y.current.unMount.add(e)}}}}),[]),De=s.useCallback(((e,r)=>async s=>{s&&(s.preventDefault&&s.preventDefault(),s.persist&&s.persist());let n=!0,a=U(B);X.current.state.next({isSubmitting:!0});try{if(t){const{errors:e,values:r}=await A.current(a,H.current,ne(Y.current.mount,B.current,k,w));C.current.errors=e,a=r}else await ve(B.current);S(C.current.errors)&&Object.keys(C.current.errors).every((e=>b(a,e)))?(X.current.state.next({errors:{},isSubmitting:!0}),await e(a,s)):(r&&await r(C.current.errors,s),v&&I(B.current,(e=>b(C.current.errors,e)),Y.current.mount))}catch(u){throw n=!1,u}finally{C.current.isSubmitted=!0,X.current.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:S(C.current.errors)&&n,submitCount:C.current.submitCount+1,errors:C.current.errors})}}),[v,re,k,w]),Se=(e,r="")=>{for(const t in e){const s=e[t],n=r+(r?".":"")+t,a=b(B.current,n);a&&a._f||(i(s)||Array.isArray(s)?Se(s,n):a||Ce(n,{value:s}))}};return s.useEffect((()=>{const e=X.current.state.subscribe({next(e){F(e,_.current,!0)&&(C.current=Object.assign(Object.assign({},C.current),e),V(C.current))}}),r=X.current.array.subscribe({next(e){if(e.values&&e.name&&_.current.isValid){const r=U(B);L(r,e.name,e.values),Oe(r)}}});return()=>{e.unsubscribe(),r.unsubscribe()}}),[]),s.useEffect((()=>{const e=[],r=e=>!be(e)||!document.contains(e);G.current||(G.current=!0,_.current.isValid&&Oe(),!O&&Se(M.current));for(const t of Y.current.unMount){const s=b(B.current,t);s&&(s._f.refs?s._f.refs.every(r):r(s._f.ref))&&e.push(t)}e.length&&Ae(e),Y.current.unMount=new Set})),{control:s.useMemo((()=>({register:Ce,inFieldArrayActionRef:$,getIsDirty:le,subjectsRef:X,watchInternal:_e,fieldsRef:B,updateIsValid:Oe,namesRef:Y,readFormStateRef:_,formStateRef:C,defaultValuesRef:M,fieldArrayDefaultValuesRef:T,setValues:ke,unregister:Ae,shouldUnmount:O})),[]),formState:D(N,j,_),trigger:pe,register:Ce,handleSubmit:De,watch:s.useCallback(((e,r)=>ae(e)?X.current.watch.subscribe({next:t=>e(_e(void 0,r),t)}):_e(e,r,!0)),[]),setValue:s.useCallback(((e,r,t={})=>{const s=b(B.current,e),n=Y.current.array.has(e);n&&(X.current.array.next({values:r,name:e,isReset:!0}),(_.current.isDirty||_.current.dirtyFields)&&t.shouldDirty&&(L(C.current.dirtyFields,e,z(r,b(M.current,e,[]),b(C.current.dirtyFields,e,[]))),X.current.state.next({name:e,dirtyFields:C.current.dirtyFields,isDirty:le(e,r)})),!r.length&&L(B.current,e,[])&&L(T.current,e,[])),(s&&!s._f||n)&&!u(r)?ke(e,r,n?{}:t):ie(e,r,t,!0,!s),te(e)&&X.current.state.next({}),X.current.watch.next({name:e,values:Ve()})}),[ke]),getValues:s.useCallback(Ve,[]),reset:s.useCallback(((e,r={})=>{const t=e||M.current;if(E&&!r.keepValues)for(const n of Y.current.mount){const e=b(B.current,n);if(e&&e._f){const r=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;try{be(r)&&r.closest("form").reset();break}catch(s){}}}!r.keepDefaultValues&&(M.current=Object.assign({},t)),r.keepValues||(B.current={},X.current.control.next({values:r.keepDefaultValues?M.current:Object.assign({},t)}),X.current.watch.next({values:Object.assign({},t)}),X.current.array.next({values:Object.assign({},t),isReset:!0})),Y.current={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1},X.current.state.next({submitCount:r.keepSubmitCount?C.current.submitCount:0,isDirty:r.keepDirty?C.current.isDirty:!!r.keepDefaultValues&&q(e,M.current),isSubmitted:!!r.keepIsSubmitted&&C.current.isSubmitted,dirtyFields:r.keepDirty?C.current.dirtyFields:{},touchedFields:r.keepTouched?C.current.touchedFields:{},errors:r.keepErrors?C.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),G.current=!!r.keepIsValid}),[]),clearErrors:s.useCallback((e=>{e?R(e).forEach((e=>J(C.current.errors,e))):C.current.errors={},X.current.state.next({errors:C.current.errors})}),[]),unregister:s.useCallback(Ae,[]),setError:s.useCallback(((e,r,t)=>{const s=((b(B.current,e)||{_f:{}})._f||{}).ref;L(C.current.errors,e,Object.assign(Object.assign({},r),{ref:s})),X.current.state.next({name:e,errors:C.current.errors,isValid:!1}),t&&t.shouldFocus&&s&&s.focus&&s.focus()}),[]),setFocus:s.useCallback((e=>b(B.current,e)._f.ref.focus()),[])}}}}]);